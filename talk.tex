\documentclass[aspectratio=169,listings,handout]{beamer}

\makeatletter
\appto\input@path{{pkgs/smile}}
\makeatother

\usetheme[color,english,listings]{zig}

\definecolor{blue}{HTML}{26547C}
\definecolor{red}{HTML}{A32638}
\definecolor{green}{HTML}{56AA1C}
\definecolor{black}{HTML}{000000}
\definecolor{white}{HTML}{F0EAD6}

\colorlet{smile@lst@color@number}{white}

\usepackage{ulem}
\def\ULthickness{3px}
\usepackage{fontspec}
\setsansfont[
	Path = ./fonts/,
	Scale = 1.2,
	Extension = .ttf,
]{Jersey}
\newfontfamily{\bubbly}[
	Path = ./fonts/,
	Scale = 1,
	Extension = .ttf,
]{04B_30__}

\setbeamerfont{title}{
	size=\huge,
	shape=\bubbly
}

\makeatletter
\lst@Key{apptoliterate}{}{\xdef\lst@literate{\unexpanded\expandafter{\lst@literate}\unexpanded{#1}}}
\makeatother
\lstset{style=smile@lst@plain}
\colorlet{smile@lst@color@tab}{darkgray!30!black}
\lstdefinelanguage{zig}{
	morekeywords={
		var,const,fn,inline,comptime,if,else,while,for,switch,return,break,continue,
		u8,u16,u32,u64,i8,i16,i32,i64,bool,void,usize,isize,type,AtomicOrder,T,
		try,catch,errdefer,struct,union,enum,extern,align,packed,
	},
	morecomment=[l]{//},
	apptoliterate=
		{?}{{{{\color{blue!70!white}?}}}}1
		{!}{{{{\color{blue!70!white}!}}}}1
		{*}{{{{\color{blue!70!white}*}}}}1
		{\&}{{{{\color{blue!70!white}\&}}}}1
		{"}{{{{\color{green!50!white}"}}}}1
		{;}{{{{\color{darkgray};}}}}1
		{...}{{{{\dots}}}}1,
	keywordstyle=\color{accent!40!white},
	commentstyle=\color{darkgray}\itshape,
}

\usepackage{emoji}
\usepackage{fontawesome5}
\usepackage{tikzpingus}

\usepackage[defaulttransition=fade,duration=45]{pdfpc}

\usepackage[strict,autostyle]{csquotes}

\def\rtem{\item[\faCaretRight]}

\def\picframe#1#2#3{
	\begin{tikzpicture}
		\node[roundednode,draw=accent,fill=accent,inner sep=0,outer sep=0,minimum width=#1+1px,minimum height=#2+1px] at (\dimexpr#1/2\relax,\dimexpr#2/2\relax) {};
		\clip[rnd] (0,0) rectangle (#1,#2);
		\node at (\dimexpr#1/2\relax,\dimexpr#2/2\relax) {\includegraphics[width=#1]{#3}};
	\end{tikzpicture}
}
\def\picframerect#1#2{\picframe{#1}{#1}{#2}}

\title{Un-locked Zig\\[1em]Synchronizing Code without Locks}
\author{Lukas Pietzschmann}
\date{October 25\textsuperscript{th}, 2025}

\begin{document}
\maketitle

\begin{frame}
	\frametitle{Motivation}
	\begin{columns}[c]
		\begin{column}{0.55\textwidth}
			\begin{itemize}[<+(1)->]
				\item Have you ever cooked with others?
				\rtem It's horrible!\par\medskip
				\item You need to coordinate who does what and when
				\rtem Otherwise, you get in each other's way\par\medskip
				\item Same problem in programming
			\end{itemize}
		\end{column}
		\begin{column}<3->{0.35\textwidth}
			\begin{center}
				\picframerect{0.8\textwidth}{images/cooks.png}\par\smallskip
				\fontsize{3pt}{3pt}\selectfont\color{gray} Generated by Google's Gemini
			\end{center}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Concurrent Programming}
	\begin{lstlisting}[language=zig]
	fun Stack(comptime T: type) type {
		return struct {
			backing: std.ArrayList(T),

			pub fn push(self: *Stack, value: T) void {
				// try self.backing.append(value);
				§\m{l1a}§const len = self.backing.items.len;
				§\m{l2a}§self.backing.items.ptr[len] = value;
				§\m{l3a}§self.backing.items.len = len + 1;
			}
		};
	}
	\end{lstlisting}
	\begin{tikzpicture}[o]
		\node[yshift=1mm,anchor=east,vo=<2|handout:0>] at (pic cs:l1a) {\small\color{blue}\faHandPointRight};
		\node[yshift=1mm,xshift=-5mm,anchor=east,vo=<4|handout:0>] at (pic cs:l1a) {\small\color{green}\faHandPointRight};

		\node[yshift=1mm,anchor=east,vo=<3-6|handout:0>] at (pic cs:l2a) {\small\color{blue}\faHandPointRight};
		\node[yshift=1mm,xshift=-5mm,anchor=east,vo=<5|handout:0>] at (pic cs:l2a) {\small\color{green}\faHandPointRight};

		\node[yshift=1mm,anchor=east,vo=<7|handout:0>] at (pic cs:l3a) {\small\color{blue}\faHandPointRight};
		\node[yshift=1mm,xshift=-5mm,anchor=east,vo=<6-7|handout:0>] at (pic cs:l3a) {\small\color{green}\faHandPointRight};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Concurrent Programming}
	\begin{lstlisting}[language=zig,basicstyle=\smile@lst@style@base\color{darkgray},keywordstyle=\color{accent!30!darkgray}]
	fun Stack(comptime T: type) type {
		return struct {
			backing: std.ArrayList(T),
			§\color{white}lock: std.Thread.Mutex,§

			pub fn push(self: *Stack, value: T) void {
				// try self.backing.append(value);
				§\m{l1b}\color{white}self.lock.lock();§
				§\m{l2b}§const len = self.backing.items.len;
				§\m{l3b}§self.backing.items.ptr[len] = value;
				§\m{l4b}§self.backing.items.len = len + 1;
				§\m{l5b}\color{white}self.lock.unlock();§
			}
		};
	}
	\end{lstlisting}
	\begin{tikzpicture}[o]
		\node[yshift=1mm,anchor=east,vo=<2|handout:0>] at (pic cs:l1b) {\small\color{blue}\faHandPointRight};
		\node[yshift=1mm,xshift=-5mm,anchor=east,vo=<5-7|handout:0>] at (pic cs:l1b) {\small\color{green}\faHandPointRight};

		\node[yshift=1mm,anchor=east,vo=<3|handout:0>] at (pic cs:l2b) {\small\color{blue}\faHandPointRight};
		\node[yshift=1mm,xshift=-5mm,anchor=east,vo=<8|handout:0>] at (pic cs:l2b) {\small\color{green}\faHandPointRight};

		\node[yshift=1mm,anchor=east,vo=<4-5|handout:0>] at (pic cs:l3b) {\small\color{blue}\faHandPointRight};
		\node[yshift=1mm,xshift=-5mm,anchor=east,vo=<9|handout:0>] at (pic cs:l3b) {\small\color{green}\faHandPointRight};

		\node[yshift=1mm,anchor=east,vo=<6|handout:0>] at (pic cs:l4b) {\small\color{blue}\faHandPointRight};
		\node[yshift=1mm,xshift=-5mm,anchor=east,vo=<10|handout:0>] at (pic cs:l4b) {\small\color{green}\faHandPointRight};

		\node[yshift=1mm,anchor=east,vo=<7-11|handout:0>] at (pic cs:l5b) {\small\color{blue}\faHandPointRight};
		\node[yshift=1mm,xshift=-5mm,anchor=east,vo=<11|handout:0>] at (pic cs:l5b) {\small\color{green}\faHandPointRight};
	\end{tikzpicture}
\end{frame}

\begin{frame}
	\frametitle{Beyond Mutual Exclusion}
	\begin{itemize}[<+(1)->]
		\item A Mutex is easy to understand and use
		\rtem Just grab it and you're safe!\par\bigskip
		\item But for more complex interactions, there are also more complex tools
		\begin{itemize}
			\item Semaphores
			\item Non-blocking Locks% try-locks
			\item Read-Write Locks
			\item Reentrant Locks% (Recursive Mutexes)
			\item Phases/Barriers
			\item\ldots
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{The hidden Costs of Locks}
	\begin{columns}[c]
		\begin{column}<2->{0.45\textwidth}
			\begin{block}[Locks seem \emph{simple} and \emph{safe}]
				\begin{itemize}[<+(2)->]
					\item But can easily create bottlenecks
					\item And add additional failure modes
					\rtem Easy to stop thinking about implications
				\end{itemize}
			\end{block}
		\end{column}
		\begin{column}<12->{0.45\textwidth}\centering
			What if we could achieve thread safety without ever forcing a thread to
			wait?\par\bigskip
			\scalebox{.7}{\begin{tikzpicture}
				\pingu[glow=accent,body type=chubby,wings wave,heart=blue,eyes wink,laptop left,laptop left mid={\tiny\color{black}Lock-free}]
			\end{tikzpicture}}
		\end{column}
	\end{columns}
	\tikzset{modal box/.append style={text width=0.88\paperwidth}}
	\begin{modal}[A selection of additional failure modes]<6-10|handout:2>
		\begin{columns}[c]
			\begin{column}{0.45\textwidth}
				\begin{itemize}\color{black}
					\item<7-> Contention\par{\small
						Multiple threads try to acquire a lock leads to performance
						degradation.}
					\item<8-> Starvation\par{\small
						When many threads compete for a lock, some threads may never get
						it.}
				\end{itemize}
			\end{column}
			\begin{column}{0.45\textwidth}\color{black}
				\begin{itemize}\color{black}
					\item<9-> Priority Inversion\par{\small
						A lower-priority thread holds a lock needed by a higher-priority
						thread.}
					\item<10-> Composability\par{\small
						Locks don't compose well, suggesting the addition of
						coarser-grained ones.}
				\end{itemize}
			\end{column}
		\end{columns}
	\end{modal}
\end{frame}

\tikzset{pps/.style={lw,rnd,shape=signal,signal from=west,signal pointer angle=130,minimum height=2cm,draw=white,fill=accent!15!black,text width=2cm,align=center}}
\usetikzlibrary{decorations.pathreplacing,positioning}
\begin{frame}<1,2|handout:2>[label=agenda,noframenumbering]
	\frametitle{Agenda}\centering
	\begin{tikzpicture}
		\node[pps,unmuted on=<1|handout:1>] (1) {What's up with Locks?};
		\node[pps,right=of 1,unmuted on=<{1,2}|handout:2>] (2) {Lock-free Coding};
		\node[pps,right=of 2,unmuted on=<{1,3}|handout:3>] (3) {Un-Locking Zig};
		\node[pps,right=of 3,unmuted on=<{1,4}|handout:4>] (4) {\includegraphics[height=1.5cm]{images/sau.png}};
		\node[yshift=2.5mm,unmuted on=<{1,4}|handout:4>] at (4.south) {\fontsize{3pt}{3pt}\selectfont\color{gray} Generated by Google's Gemini};
	\end{tikzpicture}
\end{frame}

% \begin{frame}
% 	\frametitle{More on Problems with Locks}
% 	\begin{itemize}
% 		\item Performance and Contention
% 			\begin{itemize}
% 				\item Contention
% 				\item Performance vs. Thread Count. With a lock, performance flattens or even degrades (thrashing).
% 				\item Amdahl's Law: The serial part of your program (the lock) dominates performance.
% 			\end{itemize}
% 		\item Deadlocks, Livelocks, Starvation
% 			\begin{itemize}
% 				\item Deadlock: Two or more threads waiting indefinitely for each other to release locks.
% 				\item Livelock: Threads are active but unable to make progress due to constant state changes.
% 				\item Starvation: A thread is perpetually denied access to resources it needs.
% 			\end{itemize}
% 		\item Priority Inversion
% 		\item Locks don't compose -> Forces coarse grained locking
% 	\end{itemize}
% \end{frame}
%
% \againframe[noframenumbering]{agenda}

\begin{frame}
	\frametitle{How to synchronize without Locks?}\pause
	\begin{block}
		The critical section should be so small that no other thread could interrupt it.
	\end{block}\par\bigskip\centering\pause
	\begin{tikzpicture}
		\pingu[glow=accent,body type=chubby,wings wave,heart=blue,eyes shiny,banner={Atomic Operations},crown]
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Our work horse: Compare and Swap (CAS)}\pause
	\m{csa}\begin{lstlisting}[language=zig]
		fn cas(pointer: *T, expected: T, new: T) bool {
			if (pointer.* != expected) {
				return false;
			}
			pointer.* = new;
			return true;
		}
	\end{lstlisting}\m{cea}\par\bigskip\pause
	\enquote{Look at this memory address. If it \emph{still} contains the value I
	\emph{expected}, then --- and \emph{only} then --- update it to my new value.}
\end{frame}

\newsavebox\pingub\savebox\pingub{\begin{tikzpicture}
	\pingu[glow=accent,body type=chubby,wings wave,heart=blue,eyes wink,banner={Optimistic Concurrency},banner font=\footnotesize]
\end{tikzpicture}}
\begin{frame}[fragile]
	\frametitle{Building upon CAS}\pause
	\begin{itemize}
		\item We can now utilize CAS to actually set a value atomically
	\end{itemize}\pause
	\begin{lstlisting}[language=zig]
		var current_val: T = atomic_load(prt);
		var new_val: T = compute(current_val);
		while (!cas(ptr, current_val, new_val)) {
			current_val = atomic_load(ptr);
			new_val = compute(current_val);
		}
	\end{lstlisting}
	\begin{itemize}
		\item<5-> Often, this logic is wrapped into \emph{atomic variables}
		\rtem<6-> They then provide atomic methods for getting, setting,\\and updating the value
	\end{itemize}\onslide<4->
	\begin{tikzpicture}[o]
		\node[anchor=south east,shift={(15mm,-15mm)}] at (current page.south east) {\rotatebox{35}{\scalebox{1}{\usebox\pingub}}};
	\end{tikzpicture}
\end{frame}

\begin{frame}[t]
	\frametitle{Levels of Freedom}
	\begin{columns}[b]\setlength{\leftmargini}{5mm}
		\begin{column}<2->{0.32\textwidth}
			\begin{block}[Obstruction Free]\small
				\begin{itemize}
					\item<3-> Weekest Guarantee
					\item<4-> Thread will proceed if all other threads stop
				\end{itemize}
			\end{block}\par\bigskip
			\begin{visibleenv}<5->
			\begin{tikzpicture}
				\node[roundednode,minimum width=\textwidth,fill=red!20!black,draw=red] (T) {Thread};
				\node[roundednode,minimum width=\textwidth,fill=brown!20!black,draw=brown,below=of T] (D) {Data};
				\node[roundednode,minimum width=\textwidth,fill=blue!20!black,draw=blue,below=of D] (O) {Other Threads};
				\node[roundednode,minimum width=.5\textwidth,fill=gray,draw=gray,anchor=west,inner sep=1pt] at (O.north) {\color{black}\tiny Suspended};

				\draw[arrow,rnd,dashed] ([xshift=-15mm]T.south) to ([xshift=-1cm]D.north) to ([xshift=-5mm]T.south);
				\draw[arrow,rnd] ([xshift=5mm]T.south) to ([xshift=1cm]D.north) to ([xshift=15mm]T.south);
				\draw[arrow,rnd] ([xshift=-15mm]O.north) to ([xshift=-1cm]D.south) to ([xshift=-5mm]O.north);
			\end{tikzpicture}
			\end{visibleenv}
		\end{column}
		\begin{column}<6->{0.32\textwidth}
			\begin{block}[Lock Free]\small
				\begin{itemize}
					\item<7-> System-wide progress
					\item<8-> At least one thread makes progress
				\end{itemize}
			\end{block}\par\bigskip
			\begin{visibleenv}<9->
			\begin{tikzpicture}
				\node[roundednode,minimum width=\textwidth,fill=red!20!black,draw=red] (T) {Thread};
				\node[roundednode,minimum width=\textwidth,fill=brown!20!black,draw=brown,below=of T] (D) {Data};
				\node[roundednode,minimum width=\textwidth,fill=blue!20!black,draw=blue,below=of D] (O) {Other Threads};

				\draw[arrow,rnd] ([xshift=-15mm]T.south) to ([xshift=-1cm]D.north) to ([xshift=-5mm]T.south);
				\draw[arrow,rnd] ([xshift=5mm]T.south) to ([xshift=1cm]D.north) to ([xshift=15mm]T.south);
				\draw[arrow,rnd,dashed] ([xshift=-15mm]O.north) to ([xshift=-1cm]D.south) to ([xshift=-5mm]O.north);
				\draw[arrow,rnd,dashed] ([xshift=5mm]O.north) to ([xshift=1cm]D.south) to ([xshift=15mm]O.north);
			\end{tikzpicture}
			\end{visibleenv}
		\end{column}
		\begin{column}<10->{0.32\textwidth}
			\begin{block}[Wait Free]\small
				\begin{itemize}
					\item<11-> Strongest Guarantee
					\item<12-> Per-thread progress
				\end{itemize}
			\end{block}\par\bigskip
			\begin{visibleenv}<13->
			\begin{tikzpicture}
				\node[roundednode,minimum width=\textwidth,fill=red!20!black,draw=red] (T) {Thread};
				\node[roundednode,minimum width=\textwidth,fill=brown!20!black,draw=brown,below=of T] (D) {Data};
				\node[roundednode,minimum width=\textwidth,fill=blue!20!black,draw=blue,below=of D] (O) {Other Threads};

				\draw[arrow,rnd] ([xshift=-15mm]T.south) to ([xshift=-1cm]D.north) to ([xshift=-5mm]T.south);
				\draw[arrow,rnd] ([xshift=5mm]T.south) to ([xshift=1cm]D.north) to ([xshift=15mm]T.south);
				\draw[arrow,rnd,dashed] ([xshift=-15mm]O.north) to ([xshift=-1cm]D.south) to ([xshift=-5mm]O.north);
				\draw[arrow,rnd] ([xshift=10mm]O.north) to ([xshift=1.5cm]D.south) to ([xshift=20mm]O.north);
			\end{tikzpicture}
			\end{visibleenv}
		\end{column}
	\end{columns}
	\begin{modal}[Blocking Algorithms]<14-|handout:2>
		\begin{itemize}\color{black}
			\item<15-> Use locks or other blocking primitives
			\item<16-> A thread holding a lock can be suspended, blocking all other threads
				indefinitely
			\rtem<17-> They don't even provide obstruction freedom!
		\end{itemize}
	\end{modal}
\end{frame}

\againframe<{1,3}|handout:3>[noframenumbering]{agenda}

\begin{frame}[fragile]
	\frametitle{Un-Locking Zig --- Atomic Operations}
	\begin{itemize}[<+(1)->]
		\item Our CPUs support atomic operations withing their instruction sets
			\begin{itemize}
				\item test-and-set, fetch-and-increment, compare-and-swap, \ldots
				\item \strut\rlap{\texttt{LOCK XCHG},}\phantom{test-and-set, }\rlap{\texttt{LOCK XADD},}\phantom{fetch-and-increment, }\rlap{\texttt{LOCK CMPXCHG},}\phantom{compare-and-swap, }\ldots
			\end{itemize}
		\rtem Lock-free programming is enabled by the hardware itself\par\medskip
		\item Zig provides access to these atomic operations via built-in functions
	\end{itemize}\pause
	\m{csa}\begin{lstlisting}[language=zig]
		fn cas(pointer: *T, expected: T, new: T) bool {
			if (pointer.* != expected) {
				return false;
			}
			pointer.* = new;
			return true;
		}
	\end{lstlisting}\m{cea}\pause
	\begin{tikzpicture}[o]
		\coordinate (csa) at (pic cs:csa);
		\coordinate (cea) at (pic cs:cea);
		\filldraw[black,opacity=.85] (current page.west|-csa) rectangle (current page.east|-cea);
		\node[anchor=west,yshift=2mm,xshift=-1mm] at ($(csa)!0.5!(cea)$) (A) {\begin{lstlisting}[language=zig,tab=]
			@cmpxchgWeak(comptime T: type,
				ptr: *T,
				expected_value: T,
				new_value: T,
				success_order: AtomicOrder,
				fail_order: AtomicOrder
			) ?T
		\end{lstlisting}};
		\node[anchor=north west,xshift=1mm] at (A.north east) {\begin{lstlisting}[language=zig,tab=]
			@cmpxchgStrong(comptime T: type,
				ptr: *T,
				expected_value: T,
				new_value: T,
				success_order: AtomicOrder,
				fail_order: AtomicOrder
			) ?T
		\end{lstlisting}};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Un-Locking Zig --- Atomic Variables}
	\begin{itemize}[<+(1)->]
		\item Zig provides atomic types in \texttt{std.atomic}
		\rtem \texttt{std.atomic.Value}\par\medskip
		\item It provides wrappers around Zig's atomic built-ins
	\end{itemize}\pause
	\m{csb}\begin{lstlisting}[language=zig]
		const std = @import("std");
		const atomic = std.atomic;

		var counter: atomic.Value(u32) = atomic.Value(u32).init(0);
		counter.fetchAdd(1, .SeqCst);
	\end{lstlisting}\m{ceb}\pause
	\begin{tikzpicture}[o]
		\coordinate (csb) at (pic cs:csa);
		\coordinate (ceb) at (pic cs:cea);
		\filldraw[black,opacity=.85] (current page.west|-csa) rectangle (current page.east|-cea);
		\node[anchor=west,yshift=2mm,xshift=-1.4mm] at ($(csa)!0.5!(cea)$) (A) {\begin{lstlisting}[language=zig,tab=]
			var counter = 0;
			@atomicRmw(u32, counter, .Add, 1, .SeqCst);
		\end{lstlisting}};
	\end{tikzpicture}
\end{frame}

\savebox\pingub{\begin{tikzpicture}
	\pingu[glow=accent,body type=chubby,right wing shock,bow tie=blue,monocle right,cane left,strawhat,strawhat ribbon=blue,pants=brown, pants bands]
\end{tikzpicture}}
\begin{frame}[fragile]
	\frametitle{Let's look at some Code --- Push}
	\begin{lstlisting}[language=zig]
		pub fn push(self: *Self, value: T) !void {
			var new_head = try self.allocator.create(Node);
			new_head.* = Node{
				.value = value,
				.next = null,
			};

			§\m{l1c}§while (true) {
			§\m{l2c}§	const old_head = self.top.load(.acquire);
			§\m{l3c}§	new_head.next = old_head;
			§\m{l4c}§	if (self.top.cmpxchgWeak(old_head, new_head, .release, .acquire) == null) {
			§\m{l5c}§		return;
				}
			}
		}
	\end{lstlisting}
	% \begin{tikzpicture}[o]
	% 	\node[yshift=1mm,anchor=east,vo=<2->] at (pic cs:l1c) {\small\color{blue}\faHandPointRight};
	% 	\node[yshift=1mm,anchor=east,vo=<3->] at (pic cs:l2c) {\small\color{blue}\faHandPointRight};
	% 	\node[yshift=1mm,anchor=east,vo=<4->] at (pic cs:l3c) {\small\color{blue}\faHandPointRight};
	% 	\node[yshift=1mm,anchor=east,vo=<5->] at (pic cs:l4c) {\small\color{blue}\faHandPointRight};
	% 	\node[yshift=1mm,anchor=east,vo=<6->] at (pic cs:l5c) {\small\color{blue}\faHandPointRight};
	% \end{tikzpicture}
	\begin{onlyenv}<2-|handout:2>
	\begin{tikzpicture}[o]
		\filldraw[black,opacity=.75] ([yshift=-1cm]current page.north west) rectangle (current page.south east);
		\node[yshift=-1cm] at (current page.center) (P) {\usebox\pingub};
		\node[shift={(1cm,2.5cm)}] at (P) (T) {Why is \texttt{next} not atomic?};
		\draw[lw,rnd,lcr] (P) to (T);
	\end{tikzpicture}
	\end{onlyenv}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's look at some Code --- Pop}
	\begin{lstlisting}[language=zig]
		pub fn pop(self: *Self) ?T {
			§\m{l1d}§while (true) {
			§\m{l2d}§	const old_head = self.top.load(.acquire) orelse {
						return null;
				};
			§\m{l3d}§	const new_head = old_head.next;
			§\m{l4d}§	if (self.top.cmpxchgWeak(old_head, new_head, .release, .acquire) == null) {
					const value = old_head.value;
					self.allocator.destroy(old_head);
					return value;
			§\m{l5d}§	}
			}
		}
	\end{lstlisting}
	% \begin{tikzpicture}[o]
	% 	\node[yshift=1mm,anchor=east,vo=<2->] at (pic cs:l1d) {\small\color{blue}\faHandPointRight};
	% 	\node[yshift=1mm,anchor=east,vo=<3->] at (pic cs:l2d) {\small\color{blue}\faHandPointRight};
	% 	\node[yshift=1mm,anchor=east,vo=<4->] at (pic cs:l3d) {\small\color{blue}\faHandPointRight};
	% 	\node[yshift=1mm,anchor=east,vo=<5->] at (pic cs:l4d) {\small\color{blue}\faHandPointRight};
	% 	\node[yshift=1mm,anchor=east,vo=<6->] at (pic cs:l5d) {\small\color{blue}\faHandPointRight};
	% \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Why does CAS take so many parameters?}
	\begin{columns}[c]
		\begin{column}<2->{0.45\textwidth}
			\begin{lstlisting}[language=zig]
				const data = 42;
				const data_ready = true;
			\end{lstlisting}
		\end{column}
		\begin{column}<3->{0.45\textwidth}
			\begin{lstlisting}[language=zig]
				while (!data_ready) {}
				use(data);
			\end{lstlisting}
		\end{column}
	\end{columns}\par\bigskip
	\begin{itemize}
		\item<4-> This seems to work, right?
		\rtem<5-> Wrong! There is no clear dependency between \texttt{data\_ready} and \texttt{data}
		\rtem<6-> The compiler \emph{and} the CPU might reorder instructions :)\par\bigskip
		\item<7-> By introducing \emph{memory barriers}, we can prevent this reordering
		\rtem<8-> Since different operations have different requirements, we need to specify them individually
	\end{itemize}
\end{frame}

\newsavebox\cmpxweak
\newsavebox\cmpxstrong
\begin{lrbox}{\cmpxweak}\color{black}\footnotesize
	\begin{lstlisting}[tab=]
		@cmpxchgWeak(comptime T: type,
			ptr: *T,
			expected_value: T,
			new_value: T,
			success_order: AtomicOrder,
			fail_order: AtomicOrder
		) ?T
	\end{lstlisting}
\end{lrbox}
\begin{lrbox}{\cmpxstrong}\color{black}\footnotesize
	\begin{lstlisting}[tab=]
		@cmpxchgStrong(comptime T: type,
			ptr: *T,
			expected_value: T,
			new_value: T,
			success_order: AtomicOrder,
			fail_order: AtomicOrder
		) ?T
	\end{lstlisting}
\end{lrbox}

\usetikzlibrary{patterns}
\begin{frame}
	\frametitle{Bringing Order to Chaos}
	\begin{columns}[t]
		\begin{column}<2->{0.32\textwidth}
			Acquire\par\bigskip
			\begin{tikzpicture}
				\node[roundednode,vo=<3->,minimum width=\textwidth,fill=blue!20!black,draw=blue] (T) {Memory Op};
				\node[roundednode,vo=<3->,minimum width=\textwidth,fill=brown!20!black,draw=brown,below=of T] (D) {Atomic Op};
				\node[roundednode,vo=<4->,minimum width=\textwidth,draw=gray,below=of D,inner sep=1mm,pattern={Lines[angle=45,line width=1px]},pattern color=gray] (B) {};
				\node[roundednode,vo=<3->,minimum width=\textwidth,fill=blue!20!black,draw=blue,below=of B] (O) {Memory Op};

				\node[circle,vo=<5->,fill=accent,inner sep=2pt,xshift=-1cm] at ($(D.south)!0.5!(B.north)$) (X1) {};
				\node[circle,vo=<6->,fill=accent,inner sep=2pt,xshift=1cm] at ($(T.south)!0.5!(D.north)$) (X2) {};

				\draw[arrow,vo=<5->] ([xshift=-1cm]T.south) to[bend right=25] (X1);
				\draw[arrow,vo=<6->,dashed] ([xshift=1cm]O.north) to[bend right=25] (X2);
			\end{tikzpicture}
		\end{column}
		\begin{column}<7->{0.32\textwidth}
			\rlap{\phantom{q}}Release\par\bigskip
			\begin{tikzpicture}
				\node[roundednode,vo=<8->,minimum width=\textwidth,fill=blue!20!black,draw=blue] (T) {Memory Op};
				\node[roundednode,vo=<9->,minimum width=\textwidth,draw=gray,below=of T,inner sep=1mm,pattern={Lines[angle=45,line width=1px]},pattern color=gray] (B) {};
				\node[roundednode,vo=<8->,minimum width=\textwidth,fill=brown!20!black,draw=brown,below=of B] (D) {Atomic Op};
				\node[roundednode,vo=<8->,minimum width=\textwidth,fill=blue!20!black,draw=blue,below=of D] (O) {Memory Op};

				\node[circle,vo=<10->,fill=accent,inner sep=2pt,xshift=-1cm] at ($(D.south)!0.5!(O.north)$) (X1) {};
				\node[circle,vo=<11->,fill=accent,inner sep=2pt,xshift=1cm] at ($(B.south)!0.5!(D.north)$) (X2) {};

				\draw[arrow,vo=<10->,dashed] ([xshift=-1cm]T.south) to[bend right=25] (X1);
				\draw[arrow,vo=<11->] ([xshift=1cm]O.north) to[bend right=25] (X2);
			\end{tikzpicture}
		\end{column}
		\begin{column}<12->{0.32\textwidth}
			AcqRel\par\bigskip
			\begin{tikzpicture}
				\node[roundednode,vo=<13->,minimum width=\textwidth,fill=blue!20!black,draw=blue] (T) {Memory Op};
				\node[roundednode,vo=<14->,minimum width=\textwidth,draw=gray,below=of T,inner sep=1mm,pattern={Lines[angle=45,line width=1px]},pattern color=gray] (B1) {};
				\node[roundednode,vo=<13->,minimum width=\textwidth,fill=brown!20!black,draw=brown,below=of B1] (D) {Atomic Op};
				\node[roundednode,vo=<14->,minimum width=\textwidth,draw=gray,below=of D,inner sep=1mm,pattern={Lines[angle=45,line width=1px]},pattern color=gray] (B2) {};
				\node[roundednode,vo=<13->,minimum width=\textwidth,fill=blue!20!black,draw=blue,below=of B2] (O) {Memory Op};

				\node[circle,vo=<15->,fill=accent,inner sep=2pt,xshift=-1cm] at ($(D.south)!0.5!(B2.north)$) (X1) {};
				\node[circle,vo=<16->,fill=accent,inner sep=2pt,xshift=1cm] at ($(B1.south)!0.5!(D.north)$) (X2) {};

				\draw[arrow,vo=<15->,dashed] ([xshift=-1cm]T.south) to[bend right=25] (X1);
				\draw[arrow,vo=<16->,dashed] ([xshift=1cm]O.north) to[bend right=25] (X2);
			\end{tikzpicture}
		\end{column}
	\end{columns}
	\tikzset{modal box/.append style={text width=0.82\paperwidth}}
	\begin{modal}<17-|handout:2>
		\begin{columns}[c]
			\begin{column}{0.45\textwidth}
				\usebox\cmpxweak
			\end{column}
			\begin{column}{0.45\textwidth}
				\usebox\cmpxstrong
			\end{column}
		\end{columns}\par\bigskip
		\begin{itemize}\color{black}\footnotesize
			\item<18-> The success order is enforced when the the actual and expected
				values match
			\item<19-> Fail order is enforced when they don't
		\end{itemize}
	\end{modal}
\end{frame}

\begin{frame}
	\frametitle{The Problem with \sout{ABBA} ABA}
	\begin{columns}[c]
		\begin{column}<+(1)->{0.32\textwidth}\centering
			\picframerect{0.9\textwidth}{images/redlight.png}\par\medskip
			\fontsize{3pt}{3pt}\selectfont\color{gray} Generated by Google's Gemini
		\end{column}
		\begin{column}<+(1)->{0.32\textwidth}\centering
			\picframerect{0.9\textwidth}{images/greenlight.png}\par\medskip
			\fontsize{3pt}{3pt}\selectfont\color{gray} Generated by Google's Gemini
		\end{column}
		\begin{column}<+(1)->{0.32\textwidth}\centering
			\picframerect{0.9\textwidth}{images/redlight.png}\par\medskip
			\fontsize{3pt}{3pt}\selectfont\color{gray} Generated by Google's Gemini
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The Solution to \sout{ABBA} ABA}
	\begin{columns}[t]
		\begin{column}<2->{0.32\textwidth}
			\faLightbulb[regular] DCAS\par\medskip
			Double CAS; not supported on most hardware.\par\medskip\onslide<3->
			\begin{lstlisting}[language=zig]
				cas(ptr, ep, ap,
				    ver, ev, av);
			\end{lstlisting}\par\medskip\onslide<4->
			Not to be confused with a wide CAS!
		\end{column}
		\begin{column}<5->{0.32\textwidth}
			\faLightbulb[regular] Pointer Tagging\par\medskip
			Only delay the problem, but can be practical.\par\medskip\onslide<6->
			On 8-bit aligned systems, 3 bits are free! We can just put the version
			there.\par\medskip\onslide<7->
			Then we don't  need DCAS!
		\end{column}
		\begin{column}<8->{0.32\textwidth}
			\faLightbulb[regular] Hazard Pointers\par\medskip
			Safe memory reclamation, but complex to implement.\par\medskip\onslide<9->
			Don't modify the CAS; prevent the \enquote{A back to A}
			part.\par\medskip\onslide<10->
			Pretty much manual garbage collection.
		\end{column}
	\end{columns}
\end{frame}

\againframe<{1,4}|handout:4>[noframenumbering]{agenda}

\savebox\pingub{\begin{tikzpicture}
	\pingu[glow=accent,body type=chubby,wings wave,heart=blue,eyes wink,banner={Wohoo Locks},banner font=\footnotesize]
\end{tikzpicture}}
\begin{frame}
	\frametitle{When Locks are good enough}
	\begin{columns}[c]
		\begin{column}<2->{0.45\textwidth}
			\begin{block}[Simplicity]
				\begin{itemize}
					\item When performance is not critical
					\item When few threads access a resource a few times
				\end{itemize}
			\end{block}
		\end{column}
		\begin{column}<3->{0.45\textwidth}
			\begin{block}[Coordination]
				\begin{itemize}
					\item When threads need to wait for each other
					\item When complex interactions are needed
				\end{itemize}
			\end{block}
		\end{column}
	\end{columns}
	\begin{tikzpicture}[o]
		\node[anchor=north,shift={(4cm,5mm)}] at (current page.north) {\rotatebox{180}{\scalebox{.7}{\usebox\pingub}}};
	\end{tikzpicture}
\end{frame}

\begin{frame}
	\frametitle{When Lock-Free shines}
	\begin{columns}[c]
		\begin{column}<2->{0.45\textwidth}
			\begin{block}[Performance]
				\begin{itemize}
					\item Better performance under oversubscription
					\item Better suited for real-time and low-latency systems
				\end{itemize}
			\end{block}
		\end{column}
		\begin{column}<3->{0.45\textwidth}
			\begin{block}[Robustness]
				\begin{itemize}
					\item No unpredictable blocking delays
					\item No deadlocks, livelocks, or priority inversions
				\end{itemize}
			\end{block}
		\end{column}
	\end{columns}
\end{frame}

\def\checkbox{\raisebox{-1pt}{\begin{tikzpicture}[baseline=-4.7pt]
	\node[roundednode,fill=black,draw=white,minimum width=2ex,minimum height=2ex] (B) {};
	\node at (B) {\scalebox{.6}{\color{white}\faCheck}};
\end{tikzpicture}}}
\begin{frame}
	\frametitle{Conclusion}
	\begin{itemize}[<+(1)->]\setlength{\itemsep}{6pt}
		\item[\checkbox] Locks have real --- often hidden --- costs
		\item[\checkbox] Non-blocking algorithms utilize atomic operations to achieve
			thread safety
		\item[\checkbox] A CAS inside a loop is the building block of many algorithms
		\item[\checkbox] While non-blocking algorithms have actual advantages, they
			also come with their own challenges
	\end{itemize}\par\bigskip\pause
	\begin{block}\large
		\centerline{Don't be afraid to use locks, but don't limit yourself to them
		either!}
	\end{block}
\end{frame}
\end{document}
